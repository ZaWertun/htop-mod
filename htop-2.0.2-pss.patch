--- a/linux/LinuxProcess.c
+++ b/linux/LinuxProcess.c
@@ -23,6 +23,7 @@
 #define PROCESS_FLAG_LINUX_VSERVER  0x0400
 #define PROCESS_FLAG_LINUX_CGROUP   0x0800
 #define PROCESS_FLAG_LINUX_OOM      0x1000
+#define PROCESS_FLAG_LINUX_SMAPS    0x2000
 
 typedef enum UnsupportedProcessFields {
    FLAGS = 9,
@@ -81,7 +82,10 @@
    #endif
    OOM = 114,
    IO_PRIORITY = 115,
-   LAST_PROCESSFIELD = 116,
+   M_PSS = 116,
+   M_SWAP = 117,
+   M_PSSWP = 118,
+   LAST_PROCESSFIELD = 119,
 } LinuxProcessField;
 
 #include "IOPriority.h"
@@ -96,6 +100,9 @@
    unsigned long long int cutime;
    unsigned long long int cstime;
    long m_share;
+   long m_pss;
+   long m_swap;
+   long m_psswp;
    long m_trs;
    long m_drs;
    long m_lrs;
@@ -214,6 +221,9 @@
 #endif
    [OOM] = { .name = "OOM", .title = "    OOM ", .description = "OOM (Out-of-Memory) killer score", .flags = PROCESS_FLAG_LINUX_OOM, },
    [IO_PRIORITY] = { .name = "IO_PRIORITY", .title = "IO ", .description = "I/O priority", .flags = PROCESS_FLAG_LINUX_IOPRIO, },
+   [M_PSS] = { .name = "M_PSS", .title = "  PSS ", .description = "proportional set size, same as M_RESIDENT but each page is divided by the number of processes sharing it.", .flags = PROCESS_FLAG_LINUX_SMAPS, },
+   [M_SWAP] = { .name = "M_SWAP", .title = " SWAP ", .description = "Size of the process's swapped pages", .flags = PROCESS_FLAG_LINUX_SMAPS, },
+   [M_PSSWP] = { .name = "M_PSSWP", .title = " PSSWP ", .description = "shows proportional swap share of this mapping, Unlike \"Swap\", this does not take into account swapped out page of underlying shmem objects.", .flags = PROCESS_FLAG_LINUX_SMAPS, },
    [LAST_PROCESSFIELD] = { .name = "*** report bug! ***", .title = NULL, .description = NULL, .flags = 0, },
 };
 
@@ -302,6 +312,9 @@
    case M_LRS: Process_humanNumber(str, lp->m_lrs * PAGE_SIZE_KB, coloring); return;
    case M_TRS: Process_humanNumber(str, lp->m_trs * PAGE_SIZE_KB, coloring); return;
    case M_SHARE: Process_humanNumber(str, lp->m_share * PAGE_SIZE_KB, coloring); return;
+   case M_PSS: Process_humanNumber(str, lp->m_pss, coloring); return;
+   case M_SWAP: Process_humanNumber(str, lp->m_swap, coloring); return;
+   case M_PSSWP: Process_humanNumber(str, lp->m_psswp, coloring); return;
    case UTIME: Process_printTime(str, lp->utime); return;
    case STIME: Process_printTime(str, lp->stime); return;
    case CUTIME: Process_printTime(str, lp->cutime); return;
@@ -381,6 +394,12 @@
       return (p2->m_trs - p1->m_trs);
    case M_SHARE:
       return (p2->m_share - p1->m_share);
+   case M_PSS:
+      return (p2->m_pss - p1->m_pss);
+   case M_SWAP:
+      return (p2->m_swap - p1->m_swap);
+   case M_PSSWP:
+      return (p2->m_psswp - p1->m_psswp);
    case UTIME:  diff = p2->utime - p1->utime; goto test_diff;
    case CUTIME: diff = p2->cutime - p1->cutime; goto test_diff;
    case STIME:  diff = p2->stime - p1->stime; goto test_diff;
--- a/linux/LinuxProcessList.c
+++ b/linux/LinuxProcessList.c
@@ -333,6 +333,83 @@
    return (errno == 0);
 }
 
+static bool LinuxProcessList_readSmapsFile(LinuxProcess* process, const char* dirname, const char* name) {
+   char buffer[4*1024+1];// 4k
+   char *bptr,*bptr_start;
+   ssize_t nread=0,tmp_nread=0;
+   snprintf(buffer, MAX_NAME, "%s/%s/smaps", dirname, name);
+   int fd = open(buffer, O_RDONLY);
+   if (fd == -1)
+      return false;
+
+   process->m_pss = 0;
+   process->m_swap = 0;
+   process->m_psswp = 0;
+   
+   //~ uint64_t tstart = g_get_monotonic_time ();
+   //~ if (strcmp(name, "2446") == 0)
+   while ( (nread =  read(fd,buffer+tmp_nread, (sizeof(buffer)-1)-tmp_nread)) > 0 ){
+        bptr_start = bptr = &buffer;
+        nread +=tmp_nread;
+        tmp_nread=0;
+        do{//parse 4k block
+            if( (bptr_start = memchr(bptr_start, 'P', (nread - (bptr_start - bptr)) )) > 0 ){
+                tmp_nread = (nread - (bptr_start - bptr));
+                if(tmp_nread > 27){
+                    if( memcmp((bptr_start-1),"\nPss:",5) == 0){
+                        process->m_pss += atoi(bptr_start+4);
+                        tmp_nread-=27;
+                        bptr_start+=27;//now we must be at the end of line "Pss:                   0 kB"
+                        
+                        if(*bptr_start == '\n'){
+                          if(tmp_nread > 28*11){//308
+                            bptr_start+=28*10;//10 lines bottom
+                            if( memcmp(bptr_start+1,"Swap:",5) == 0){// Swap:                  0 kB
+                              process->m_swap += atoi((bptr_start+6));
+                            }
+                            bptr_start-=28*10;
+                          }
+                          
+                          if(tmp_nread > 28*12){//336
+                            bptr_start+=28*11;
+                            if( memcmp(bptr_start+1,"SwapPss:",8) == 0){// SwapPss:               0 kB
+                              process->m_psswp += atoi((bptr_start+9));
+                            }
+                            bptr_start-=28*11;
+                          }
+                        }//if \n
+                        if(tmp_nread > 512){
+                          bptr_start += 512;//skip 512 chars, there will not be Pss:
+                        }else{
+                          tmp_nread=0;
+                          break;//read next 4k block
+                        }
+
+                        continue;//find next in this 4k block
+                    }else{
+                        bptr_start++;//mismatch
+                        continue;
+                    }
+                }else{//not enought bytes, copy rest and read next block
+                    if(tmp_nread > 0){
+                        //rollback by one char,we need to know what was before 'P' in next cycle
+                        bptr_start--;
+                        tmp_nread++;
+                        memcpy(buffer,bptr_start,tmp_nread);
+                    }else
+                        tmp_nread=0;
+                    break;//read next 4k block
+                }
+            }else{
+                break;//read next 4k block
+            }
+        }while(1);
+   }//while read
+  //~ process->m_pss = (g_get_monotonic_time ()-tstart)/1000;
+   close(fd);
+   return true;
+}
+
 #ifdef HAVE_OPENVZ
 
 static void LinuxProcessList_readOpenVZData(LinuxProcess* process, const char* dirname, const char* name) {
@@ -557,6 +634,14 @@
       if (! LinuxProcessList_readStatmFile(lp, dirname, name))
          goto errorReadingProcess;
 
+      if ((settings->flags &  PROCESS_FLAG_LINUX_SMAPS ) && !Process_isKernelThread(proc)){
+        if( !parent){
+            LinuxProcessList_readSmapsFile(lp, dirname, name);
+        }else{
+            lp->m_pss = ((LinuxProcess*)parent)->m_pss;
+        }
+      }
+
       proc->show = ! ((hideKernelThreads && Process_isKernelThread(proc)) || (hideUserlandThreads && Process_isUserlandThread(proc)));
 
       char command[MAX_NAME+1];
--- a/linux/Platform.c
+++ b/linux/Platform.c
@@ -41,7 +41,7 @@
 #define CLAMP(x,low,high) (((x)>(high))?(high):(((x)<(low))?(low):(x)))
 #endif
 
-ProcessField Platform_defaultFields[] = { PID, USER, PRIORITY, NICE, M_SIZE, M_RESIDENT, M_SHARE, STATE, PERCENT_CPU, PERCENT_MEM, TIME, COMM, 0 };
+ProcessField Platform_defaultFields[] = { PID, USER, PRIORITY, NICE, M_SIZE, M_RESIDENT, M_PSS, M_SHARE, STATE, PERCENT_CPU, PERCENT_MEM, TIME, COMM, 0 };
 
 //static ProcessField defaultIoFields[] = { PID, IO_PRIORITY, USER, IO_READ_RATE, IO_WRITE_RATE, IO_RATE, COMM, 0 };
 
