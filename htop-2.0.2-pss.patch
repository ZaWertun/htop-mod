--- a/linux/LinuxProcess.c
+++ b/linux/LinuxProcess.c
@@ -23,6 +23,7 @@
 #define PROCESS_FLAG_LINUX_VSERVER  0x0400
 #define PROCESS_FLAG_LINUX_CGROUP   0x0800
 #define PROCESS_FLAG_LINUX_OOM      0x1000
+#define PROCESS_FLAG_LINUX_PSS      0x2000
 
 typedef enum UnsupportedProcessFields {
    FLAGS = 9,
@@ -81,7 +82,8 @@
    #endif
    OOM = 114,
    IO_PRIORITY = 115,
-   LAST_PROCESSFIELD = 116,
+   M_PSS = 116,
+   LAST_PROCESSFIELD = 117,
 } LinuxProcessField;
 
 #include "IOPriority.h"
@@ -96,6 +98,7 @@
    unsigned long long int cutime;
    unsigned long long int cstime;
    long m_share;
+   long m_pss;
    long m_trs;
    long m_drs;
    long m_lrs;
@@ -214,6 +217,7 @@
 #endif
    [OOM] = { .name = "OOM", .title = "    OOM ", .description = "OOM (Out-of-Memory) killer score", .flags = PROCESS_FLAG_LINUX_OOM, },
    [IO_PRIORITY] = { .name = "IO_PRIORITY", .title = "IO ", .description = "I/O priority", .flags = PROCESS_FLAG_LINUX_IOPRIO, },
+   [M_PSS] = { .name = "M_PSS", .title = "  PSS ", .description = "proportional set size, same as RSS but each page is divided by the number of processes sharing it.", .flags = PROCESS_FLAG_LINUX_PSS, },
    [LAST_PROCESSFIELD] = { .name = "*** report bug! ***", .title = NULL, .description = NULL, .flags = 0, },
 };
 
@@ -302,6 +306,7 @@
    case M_LRS: Process_humanNumber(str, lp->m_lrs * PAGE_SIZE_KB, coloring); return;
    case M_TRS: Process_humanNumber(str, lp->m_trs * PAGE_SIZE_KB, coloring); return;
    case M_SHARE: Process_humanNumber(str, lp->m_share * PAGE_SIZE_KB, coloring); return;
+   case M_PSS: Process_humanNumber(str, lp->m_pss, coloring); return;
    case UTIME: Process_printTime(str, lp->utime); return;
    case STIME: Process_printTime(str, lp->stime); return;
    case CUTIME: Process_printTime(str, lp->cutime); return;
@@ -381,6 +386,8 @@
       return (p2->m_trs - p1->m_trs);
    case M_SHARE:
       return (p2->m_share - p1->m_share);
+   case M_PSS:
+      return (p2->m_pss - p1->m_pss);
    case UTIME:  diff = p2->utime - p1->utime; goto test_diff;
    case CUTIME: diff = p2->cutime - p1->cutime; goto test_diff;
    case STIME:  diff = p2->stime - p1->stime; goto test_diff;
--- a/linux/LinuxProcessList.c
+++ b/linux/LinuxProcessList.c
@@ -333,6 +333,163 @@
    return (errno == 0);
 }
 
+int handle_virtual_range(int pagemap, unsigned long start_address,
+    unsigned long end_address) {
+    int mpss=0;
+    for(unsigned long i = start_address; i < end_address; i += 0x1000) {
+        unsigned long data;
+        unsigned long index = (i / PAGE_SIZE) * sizeof(data);
+        if(pread(pagemap, &data, sizeof(data), index) != sizeof(data)) {
+                if(errno) perror("pread");
+                break;
+        }
+        mpss++;
+    }
+    return mpss;
+}
+
+
+static unsigned long parse_hex(char **buf){
+    unsigned long low = 0;
+    const char *end=*buf+16;
+    while(*buf < end ) {
+        low *= 16;
+        char c = **buf;
+        if(c >= '0' && c <= '9') {
+            low += c - '0';
+        }
+        else if(c >= 'a' && c <= 'f') {
+            low += c - 'a' + 10;
+        }
+        else break;
+        (*buf)++;
+    }
+    return low;
+}
+
+static bool LinuxProcessList_readSmapsFile(LinuxProcess* process, const char* dirname, const char* name) {
+
+if (!(strcmp(name, "2446") == 0 || strcmp(name, "2492") == 0)) return false;
+    char buffer[4*1024+1];// 4k
+    snprintf(buffer, MAX_NAME,
+        "%s/%s/maps",dirname, name);
+    int maps = open(buffer, O_RDONLY);
+    if(maps < 0) return false;
+
+    snprintf(buffer, MAX_NAME,
+        "%s/%s/pagemap",dirname, name);
+
+
+    int pagemap = open(buffer, O_RDONLY);
+    if(pagemap < 0) {
+        close(maps);
+        return false;
+    }
+
+    //~ char buffer[BUFSIZ];
+    int offset = 0;
+    process->m_pss = 0;
+
+    for(;;) {
+        ssize_t length = read(maps, buffer + offset, sizeof buffer - offset);
+        if(length <= 0) break;
+
+        length += offset;
+        offset=0;
+        char *bptr = &buffer;
+        char *bptr_start = bptr;
+        char *bptr_end = bptr;
+        do{
+            unsigned long low = 0, high = 0;
+            
+            do{
+                low=parse_hex(&bptr_start);
+                if(*bptr_start!='-') break;
+                bptr_start++;
+                high=parse_hex(&bptr_start);
+                if(*bptr_start!=' ') break;
+                bptr_start++;
+                process->m_pss += handle_virtual_range(pagemap, low, high);
+            }while(0);
+            offset=(length - (bptr_start - bptr));
+            if( offset >0 && (bptr_end = memchr(bptr_start, '\n', offset )) > 0 ){
+                if((length - (bptr_end - bptr))>34){
+                    bptr_start=++bptr_end;
+                    continue;
+                }
+            }
+            
+            if(offset > 0)
+                memcpy(buffer,bptr_start,offset);
+            else
+                offset=0;
+            break;
+        }while(1);
+    }
+
+    close(maps);
+    close(pagemap);
+}
+
+static bool LinuxProcessList_readSmapsFile2(LinuxProcess* process, const char* dirname, const char* name) {
+   int line_pss;
+   char buffer[4*1024+1];// 4k
+   char *bptr,*bptr_start;
+   ssize_t nread=0,tmp_nread=0;
+   snprintf(buffer, MAX_NAME, "%s/%s/smaps", dirname, name);
+   int fd = open(buffer, O_RDONLY);
+   if (fd == -1)
+      return false;
+
+   process->m_pss = 0;
+   
+   //~ uint64_t tstart = g_get_monotonic_time ();
+   //~ if (strcmp(name, "2446") == 0)
+   while ( (nread =  read(fd,buffer+tmp_nread, (sizeof(buffer)-1)-tmp_nread)) > 0 ){
+        bptr_start = bptr = &buffer;
+        nread +=tmp_nread;
+        tmp_nread=0;
+        do{//parse 4k block
+            if( (bptr_start = memchr(bptr_start, 'P', (nread - (bptr_start - bptr)) )) > 0 ){
+                tmp_nread = (nread - (bptr_start - bptr));
+                if(tmp_nread > 23){
+                    if( *(bptr_start-1) == '\n' && *++bptr_start == 's' && *++bptr_start ==  's' && *++bptr_start ==  ':'){
+                        line_pss = atoi(++bptr_start);
+                        process->m_pss += line_pss;
+                        tmp_nread-=23;
+                        bptr_start+=23; //add value lenght
+                        if(tmp_nread > 512){
+                          bptr_start += 512;//skip 512 chars, there will not be Pss:
+                        }else{
+                          tmp_nread=0;
+                          break;//read next 4k block
+                        }
+
+                        continue;//find next in this 4k block
+                    }else{
+                        bptr_start++;//mismatch
+                        continue;
+                    }
+                }else{//not enought bytes, copy rest and read next block
+                    if(tmp_nread > 0){
+                        //rollback by one char,we need to know what was before 'P' in next cycle
+                        bptr_start--;
+                        tmp_nread++;
+                        memcpy(buffer,bptr_start,tmp_nread);
+                    }else
+                        tmp_nread=0;
+                    break;//read next 4k block
+                }
+            }else{
+                break;//read next 4k block
+            }
+        }while(1);
+   }//while read
+  //~ process->m_pss = (g_get_monotonic_time ()-tstart)/1000;
+   close(fd);
+   return true;
+}
+
 #ifdef HAVE_OPENVZ
 
 static void LinuxProcessList_readOpenVZData(LinuxProcess* process, const char* dirname, const char* name) {
@@ -557,6 +714,14 @@
       if (! LinuxProcessList_readStatmFile(lp, dirname, name))
          goto errorReadingProcess;
 
+      if ((settings->flags &  PROCESS_FLAG_LINUX_PSS ) && !Process_isKernelThread(proc)){
+        if( !parent){
+            LinuxProcessList_readSmapsFile(lp, dirname, name);
+        }else{
+            lp->m_pss = ((LinuxProcess*)parent)->m_pss;
+        }
+      }
+
       proc->show = ! ((hideKernelThreads && Process_isKernelThread(proc)) || (hideUserlandThreads && Process_isUserlandThread(proc)));
 
       char command[MAX_NAME+1];
--- a/linux/Platform.c
+++ b/linux/Platform.c
@@ -41,7 +41,7 @@
 #define CLAMP(x,low,high) (((x)>(high))?(high):(((x)<(low))?(low):(x)))
 #endif
 
-ProcessField Platform_defaultFields[] = { PID, USER, PRIORITY, NICE, M_SIZE, M_RESIDENT, M_SHARE, STATE, PERCENT_CPU, PERCENT_MEM, TIME, COMM, 0 };
+ProcessField Platform_defaultFields[] = { PID, USER, PRIORITY, NICE, M_SIZE, M_RESIDENT, M_PSS, M_SHARE, STATE, PERCENT_CPU, PERCENT_MEM, TIME, COMM, 0 };
 
 //static ProcessField defaultIoFields[] = { PID, IO_PRIORITY, USER, IO_READ_RATE, IO_WRITE_RATE, IO_RATE, COMM, 0 };
 
