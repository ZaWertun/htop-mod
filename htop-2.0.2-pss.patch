--- a/linux/LinuxProcess.c
+++ b/linux/LinuxProcess.c
@@ -23,6 +23,7 @@
 #define PROCESS_FLAG_LINUX_VSERVER  0x0400
 #define PROCESS_FLAG_LINUX_CGROUP   0x0800
 #define PROCESS_FLAG_LINUX_OOM      0x1000
+#define PROCESS_FLAG_LINUX_SMAPS    0x2000
 
 typedef enum UnsupportedProcessFields {
    FLAGS = 9,
@@ -81,7 +82,10 @@
    #endif
    OOM = 114,
    IO_PRIORITY = 115,
-   LAST_PROCESSFIELD = 116,
+   M_PSS = 116,
+   M_SWAP = 117,
+   M_PSSWP = 118,
+   LAST_PROCESSFIELD = 119,
 } LinuxProcessField;
 
 #include "IOPriority.h"
@@ -96,6 +100,9 @@
    unsigned long long int cutime;
    unsigned long long int cstime;
    long m_share;
+   long m_pss;
+   long m_swap;
+   long m_psswp;
    long m_trs;
    long m_drs;
    long m_lrs;
@@ -214,6 +221,9 @@
 #endif
    [OOM] = { .name = "OOM", .title = "    OOM ", .description = "OOM (Out-of-Memory) killer score", .flags = PROCESS_FLAG_LINUX_OOM, },
    [IO_PRIORITY] = { .name = "IO_PRIORITY", .title = "IO ", .description = "I/O priority", .flags = PROCESS_FLAG_LINUX_IOPRIO, },
+   [M_PSS] = { .name = "M_PSS", .title = "  PSS ", .description = "proportional set size, same as M_RESIDENT but each page is divided by the number of processes sharing it.", .flags = PROCESS_FLAG_LINUX_SMAPS, },
+   [M_SWAP] = { .name = "M_SWAP", .title = " SWAP ", .description = "Size of the process's swapped pages", .flags = PROCESS_FLAG_LINUX_SMAPS, },
+   [M_PSSWP] = { .name = "M_PSSWP", .title = " PSSWP ", .description = "shows proportional swap share of this mapping, Unlike \"Swap\", this does not take into account swapped out page of underlying shmem objects.", .flags = PROCESS_FLAG_LINUX_SMAPS, },
    [LAST_PROCESSFIELD] = { .name = "*** report bug! ***", .title = NULL, .description = NULL, .flags = 0, },
 };
 
@@ -302,6 +312,9 @@
    case M_LRS: Process_humanNumber(str, lp->m_lrs * PAGE_SIZE_KB, coloring); return;
    case M_TRS: Process_humanNumber(str, lp->m_trs * PAGE_SIZE_KB, coloring); return;
    case M_SHARE: Process_humanNumber(str, lp->m_share * PAGE_SIZE_KB, coloring); return;
+   case M_PSS: Process_humanNumber(str, lp->m_pss, coloring); return;
+   case M_SWAP: Process_humanNumber(str, lp->m_swap, coloring); return;
+   case M_PSSWP: Process_humanNumber(str, lp->m_psswp, coloring); return;
    case UTIME: Process_printTime(str, lp->utime); return;
    case STIME: Process_printTime(str, lp->stime); return;
    case CUTIME: Process_printTime(str, lp->cutime); return;
@@ -381,6 +394,12 @@
       return (p2->m_trs - p1->m_trs);
    case M_SHARE:
       return (p2->m_share - p1->m_share);
+   case M_PSS:
+      return (p2->m_pss - p1->m_pss);
+   case M_SWAP:
+      return (p2->m_swap - p1->m_swap);
+   case M_PSSWP:
+      return (p2->m_psswp - p1->m_psswp);
    case UTIME:  diff = p2->utime - p1->utime; goto test_diff;
    case CUTIME: diff = p2->cutime - p1->cutime; goto test_diff;
    case STIME:  diff = p2->stime - p1->stime; goto test_diff;
--- a/linux/LinuxProcessList.c
+++ b/linux/LinuxProcessList.c
@@ -333,6 +333,54 @@
    return (errno == 0);
 }
 
+static bool LinuxProcessList_readSmapsFile(LinuxProcess* process, const char* dirname, const char* name) {
+   char buffer[4*1024+1];// 4k
+   char *bptr_start,*bptr_end;
+   ssize_t nread=0;
+   int tmp=0;
+   snprintf(buffer, MAX_NAME, "%s/%s/smaps", dirname, name);
+   int fd = open(buffer, O_RDONLY);
+   if (fd == -1)
+      return false;
+
+   process->m_pss = 0;
+   process->m_swap = 0;
+   process->m_psswp = 0;
+   
+   //~ uint64_t tstart = g_get_monotonic_time ();
+   //~ if (strcmp(name, "2446") == 0)
+   while ( (nread =  read(fd,buffer, (sizeof(buffer)-1))) > 0 ){
+        bptr_start = &buffer;
+        bptr_end   = bptr_start + nread;
+        do{//parse 4k block
+
+            if( (tmp = (bptr_end - bptr_start)) >0 &&
+                (bptr_start = memmem(bptr_start,tmp,"\nPss:",5)) >0 )
+            {
+                process->m_pss += strtol(bptr_start+5,&bptr_start,10);
+                bptr_start+=3;//now we must be at the end of line "Pss:                   0 kB"
+                
+                if( (tmp = (bptr_end - bptr_start)) >0 &&
+                    (bptr_start = memmem(bptr_start,tmp,"\nSwap:",6)) >0 ){
+                            process->m_swap += strtol(bptr_start+6,&bptr_start,10);
+                            bptr_start+=3;//now we must be at the end of line "Swap:                   0 kB"
+                }else break;
+                
+                
+                if( (tmp = (bptr_end - bptr_start)) >0 &&
+                    (bptr_start = memmem(bptr_start,tmp,"\nSwapPss:",9)) >0 ){
+                            process->m_psswp += strtol(bptr_start+9,&bptr_start,10);
+                            bptr_start+=3;//now we must be at the end of line "SwapPss:                   0 kB"
+                }else break;
+
+            }else break;//read next 4k block
+        }while(1);
+   }//while read
+  //~ process->m_pss = (g_get_monotonic_time ()-tstart)/1000;
+   close(fd);
+   return true;
+}
+
 #ifdef HAVE_OPENVZ
 
 static void LinuxProcessList_readOpenVZData(LinuxProcess* process, const char* dirname, const char* name) {
@@ -557,6 +605,14 @@
       if (! LinuxProcessList_readStatmFile(lp, dirname, name))
          goto errorReadingProcess;
 
+      if ((settings->flags &  PROCESS_FLAG_LINUX_SMAPS ) && !Process_isKernelThread(proc)){
+        if( !parent){
+            LinuxProcessList_readSmapsFile(lp, dirname, name);
+        }else{
+            lp->m_pss = ((LinuxProcess*)parent)->m_pss;
+        }
+      }
+
       proc->show = ! ((hideKernelThreads && Process_isKernelThread(proc)) || (hideUserlandThreads && Process_isUserlandThread(proc)));
 
       char command[MAX_NAME+1];
--- a/linux/Platform.c
+++ b/linux/Platform.c
@@ -41,7 +41,7 @@
 #define CLAMP(x,low,high) (((x)>(high))?(high):(((x)<(low))?(low):(x)))
 #endif
 
-ProcessField Platform_defaultFields[] = { PID, USER, PRIORITY, NICE, M_SIZE, M_RESIDENT, M_SHARE, STATE, PERCENT_CPU, PERCENT_MEM, TIME, COMM, 0 };
+ProcessField Platform_defaultFields[] = { PID, USER, PRIORITY, NICE, M_SIZE, M_RESIDENT, M_PSS, M_SHARE, STATE, PERCENT_CPU, PERCENT_MEM, TIME, COMM, 0 };
 
 //static ProcessField defaultIoFields[] = { PID, IO_PRIORITY, USER, IO_READ_RATE, IO_WRITE_RATE, IO_RATE, COMM, 0 };
 
